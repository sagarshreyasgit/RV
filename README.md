# RISC-V Processor Extension

This repository contains modifications to a RISC-V single-cycle processor to add new instructions, based on the assignment requirements. The changes focus on both instruction recognition and execution, enhancing the processor's capabilities.

## Overview

The core goal of these modifications is to extend the processor from **recognition to execution**:

1. **Control Unit (The Brain)**  
   - Responsible for decoding instructions.  
   - Updated to recognize new instruction patterns and generate the appropriate control signals.

2. **Datapath (The Brawn)**  
   - Contains functional units like the ALU.  
   - Extended to perform the new operations by implementing the necessary hardware logic.
   
The changes flow in the same sequence that an instruction does through the processor: first decoding, then execution.

### Change 1: Recognizing the New Instruction Family (maindec module)

A new entry was added to the `case` statement inside the `maindec` (Main Decoder) module for the new opcode `7'b0001011`.

```verilog
// In maindec module
case(op)
  // ... existing opcodes ...
  // MODIFIED: Added case for RVX10 custom instructions
  7'b0001011: controls = 11'b1_xx_0_0_00_0_11_0; // RVX10 (R-Type)
  default:    controls = 11'bx_xx_x_x_xx_x_xx_x;
endcase
```
The `maindec` is the first part of the control unit to inspect an instruction. It only looks at the 7-bit `opcode`. The assignment specifies that all 10 new RVX10 instructions share the same `CUSTOM-0` opcode (`0x0B` or `7'b0001011`). We needed to teach the main decoder to recognize this opcode and generate the correct high-level control signals for it.

The control signals set for this opcode (`11'b1_xx_0_0_00_0_11_0`) tell the datapath to perform an action typical of an R-type instruction:

- `RegWrite = 1`: The result will be written back to the register file.
- `ALUSrc = 0`: The second operand for the ALU should come from a register (`rs2`), not an immediate value.
- `MemWrite = 0`: It does not write to memory.
- `ResultSrc = 00`: The value written to the register file comes from the ALU result.
- `Branch = 0, Jump = 0`: It's not a control-flow instruction.
- Crucially, `ALUOp = 11`: This is a new, custom signal sent to the next stage of the decoder (`aludec`). It essentially means: "This is a special custom instruction; needed to look at `funct3` and `funct7` to figure out the details."

### Change 2: Differentiating Between the 10 New Instructions (`aludec` module)

The ALU Decoder (`aludec`) was significantly expanded. A new case for 
`ALUOp == 2'b11` was added, which contains a nested `case` statement that 
inspects the `funct7` and `funct3` fields to generate a unique `ALUControl` 
signal for each of the 10 new instructions.

```verilog
// In aludec module
case(ALUOp)
  // ... existing ALUOp cases ...
  // MODIFIED: Added case for RVX10 instructions
  2'b11: case(funct7)
    7'b0000000: case(funct3) // For ANDN, ORN, XNOR
      3'b000: ALUControl = 5'b01000; // ANDN
      3'b001: ALUControl = 5'b01001; // ORN
      // ... and so on for all 10 instructions
    endcase
    // ... other funct7 cases ...
  endcase
endcase
```
While `maindec` recognizes the family of RVX10 instructions, `aludec` must figure out exactly which one it is. The assignment document provides a table showing that `funct7` and `funct3` are used to distinguish between `ANDN`, `MIN`, `ROL`, etc. This module is responsible for that fine-grained decoding.

The logic directly implements the table from the PDF. When `aludec` receives `ALUOp = 11`, it knows it's an RVX10 instruction. It then uses `funct7` as the primary selector and `funct3` as the secondary selector to pinpoint the exact operation and output a unique 5-bit code (`ALUControl`) for the ALU.

### Change 3: Expanding the ALU's Vocabulary (`ALUControl` signal)

The width of the `ALUControl` signal was increased from 3 bits (`logic [2:0]`) to 5 bits (`logic [4:0]`) throughout the design.

A 3-bit signal can only represent \( 2^3 = 8 \) unique operations. The original processor used about 5 of these. To add 10 *new* operations, we needed more unique codes.  
A 4-bit signal would provide 16 combinations, which would be a tight fit.  
A 5-bit signal provides \( 2^5 = 32 \) combinations, offering plenty of space for the original operations and the 10 new ones without any ambiguity.

This change required updating the signal declaration in the port lists and wire definitions of every module that uses it: `riscvsingle`, `controller`, `aludec`, `datapath`, and `alu`.

### Change 4: Implementing the New Operations (`alu` module)

The `case` statement in the `alu` module was expanded to include logic for the 10 new `ALUControl` codes generated by the `aludec`.

```verilog
// In alu module
case (alucontrol)
  // ... base ISA operations ...

  // RVX10 custom operations
  5'b01000: result = a & ~b;                                                     // ANDN
  5'b01001: result = a | ~b;                                                     // ORN
  5'b01010: result = ~(a ^ b);                                                   // XNOR
  5'b01011: result = (signed_a < signed_b) ? a : b;                              // MIN
  5'b01100: result = (signed_a > signed_b) ? a : b;                              // MAX
  5'b01101: result = (a < b) ? a : b;                                            // MINU
  5'b01110: result = (a > b) ? a : b;                                            // MAXU
  5'b01111: result = (shamt == 5'b0) ? a : (a << shamt) | (a >> (32 - shamt));    // ROL
  5'b10000: result = (shamt == 5'b0) ? a : (a >> shamt) | (a << (32 - shamt));    // ROR
  5'b10001: result = (signed_a >= 32'sd0) ? a : -signed_a;                       // ABS
  default: result = 32'bx;
endcase
```
This is the final and most critical step. The decoders have figured out *what* to do, but the `alu` is the module that actually *does* it. We needed to add the SystemVerilog expressions that perform the semantics of each new instruction (e.g., bitwise AND with an inverted operand for `ANDN`, signed comparison for `MIN`, etc.).

For each new 5-bit `ALUControl` code, a new entry was added to the `case` statement with the corresponding logic:

- **Bitwise (`ANDN`, `ORN`, `XNOR`)**:  
  Implemented using Verilog's standard bitwise operators (`&`, `|`, `~`, `^`).

- **Comparisons (`MIN`, `MAX`, `MINU`, `MAXU`)**:  
  - For the signed versions (`MIN` / `MAX`), the inputs were cast to a `signed` type to ensure correct two's complement comparison.  
  - For the unsigned versions, Verilog's default unsigned comparison was used.

- **Rotates (`ROL`, `ROR`)**:  
  Implemented using a combination of left and right shifts and a bitwise OR, as is standard.  
  A specific check (`shamt == 0`) was added to handle the rotate-by-zero case and prevent an invalid shift-by-32, as required by the assignment.

- **Absolute Value (`ABS`)**:  
  A signed comparison checks if the input is non-negative. If it is, the original value is passed through; otherwise, its two's complement negative is calculated and returned.
