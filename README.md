# RISC-V Processor Extension

This repository contains modifications to a RISC-V single-cycle processor to add new instructions, based on the assignment requirements. The changes focus on both instruction recognition and execution, enhancing the processor's capabilities.

## Overview

The core goal of these modifications is to extend the processor from **recognition to execution**:

1. **Control Unit (The Brain)**  
   - Responsible for decoding instructions.  
   - Updated to recognize new instruction patterns and generate the appropriate control signals.

2. **Datapath (The Brawn)**  
   - Contains functional units like the ALU.  
   - Extended to perform the new operations by implementing the necessary hardware logic.
   
The changes flow in the same sequence that an instruction does through the processor: first decoding, then execution.

### Change 1: Recognizing the New Instruction Family (maindec module)

A new entry was added to the `case` statement inside the `maindec` (Main Decoder) module for the new opcode `7'b0001011`.

```verilog
// In maindec module
case(op)
  // ... existing opcodes ...
  // MODIFIED: Added case for RVX10 custom instructions
  7'b0001011: controls = 11'b1_xx_0_0_00_0_11_0; // RVX10 (R-Type)
  default:    controls = 11'bx_xx_x_x_xx_x_xx_x;
endcase
```
The `maindec` is the first part of the control unit to inspect an instruction. It only looks at the 7-bit `opcode`. The assignment specifies that all 10 new RVX10 instructions share the same `CUSTOM-0` opcode (`0x0B` or `7'b0001011`). We needed to teach the main decoder to recognize this opcode and generate the correct high-level control signals for it.

The control signals set for this opcode (`11'b1_xx_0_0_00_0_11_0`) tell the datapath to perform an action typical of an R-type instruction:

- `RegWrite = 1`: The result will be written back to the register file.
- `ALUSrc = 0`: The second operand for the ALU should come from a register (`rs2`), not an immediate value.
- `MemWrite = 0`: It does not write to memory.
- `ResultSrc = 00`: The value written to the register file comes from the ALU result.
- `Branch = 0, Jump = 0`: It's not a control-flow instruction.
- Crucially, `ALUOp = 11`: This is a new, custom signal sent to the next stage of the decoder (`aludec`). It essentially means: "This is a special custom instruction; needed to look at `funct3` and `funct7` to figure out the details."

### Change 2: Differentiating Between the 10 New Instructions (`aludec` module)

The ALU Decoder (`aludec`) was significantly expanded. A new case for 
`ALUOp == 2'b11` was added, which contains a nested `case` statement that 
inspects the `funct7` and `funct3` fields to generate a unique `ALUControl` 
signal for each of the 10 new instructions.

```verilog
// In aludec module
case(ALUOp)
  // ... existing ALUOp cases ...
  // MODIFIED: Added case for RVX10 instructions
  2'b11: case(funct7)
    7'b0000000: case(funct3) // For ANDN, ORN, XNOR
      3'b000: ALUControl = 5'b01000; // ANDN
      3'b001: ALUControl = 5'b01001; // ORN
      // ... and so on for all 10 instructions
    endcase
    // ... other funct7 cases ...
  endcase
endcase
```
While `maindec` recognizes the family of RVX10 instructions, `aludec` must figure out exactly which one it is. The assignment document provides a table showing that `funct7` and `funct3` are used to distinguish between `ANDN`, `MIN`, `ROL`, etc. This module is responsible for that fine-grained decoding.

The logic directly implements the table from the PDF. When `aludec` receives `ALUOp = 11`, it knows it's an RVX10 instruction. It then uses `funct7` as the primary selector and `funct3` as the secondary selector to pinpoint the exact operation and output a unique 5-bit code (`ALUControl`) for the ALU.

### Change 3: Expanding the ALU's Vocabulary (`ALUControl` signal)

The width of the `ALUControl` signal was increased from 3 bits (`logic [2:0]`) to 5 bits (`logic [4:0]`) throughout the design.

A 3-bit signal can only represent \( 2^3 = 8 \) unique operations. The original processor used about 5 of these. To add 10 *new* operations, we needed more unique codes.  
A 4-bit signal would provide 16 combinations, which would be a tight fit.  
A 5-bit signal provides \( 2^5 = 32 \) combinations, offering plenty of space for the original operations and the 10 new ones without any ambiguity.

This change required updating the signal declaration in the port lists and wire definitions of every module that uses it: `riscvsingle`, `controller`, `aludec`, `datapath`, and `alu`.

### Change 4: Implementing the New Operations (`alu` module)

The `case` statement in the `alu` module was expanded to include logic for the 10 new `ALUControl` codes generated by the `aludec`.

```verilog
// In alu module
case (alucontrol)
  // ... base ISA operations ...

  // RVX10 custom operations
  5'b01000: result = a & ~b;                                                     // ANDN
  5'b01001: result = a | ~b;                                                     // ORN
  5'b01010: result = ~(a ^ b);                                                   // XNOR
  5'b01011: result = (signed_a < signed_b) ? a : b;                              // MIN
  5'b01100: result = (signed_a > signed_b) ? a : b;                              // MAX
  5'b01101: result = (a < b) ? a : b;                                            // MINU
  5'b01110: result = (a > b) ? a : b;                                            // MAXU
  5'b01111: result = (shamt == 5'b0) ? a : (a << shamt) | (a >> (32 - shamt));    // ROL
  5'b10000: result = (shamt == 5'b0) ? a : (a >> shamt) | (a << (32 - shamt));    // ROR
  5'b10001: result = (signed_a >= 32'sd0) ? a : -signed_a;                       // ABS
  default: result = 32'bx;
endcase
```
This is the final and most critical step. The decoders have figured out *what* to do, but the `alu` is the module that actually *does* it. We needed to add the SystemVerilog expressions that perform the semantics of each new instruction (e.g., bitwise AND with an inverted operand for `ANDN`, signed comparison for `MIN`, etc.).

For each new 5-bit `ALUControl` code, a new entry was added to the `case` statement with the corresponding logic:

- **Bitwise (`ANDN`, `ORN`, `XNOR`)**:  
  Implemented using Verilog's standard bitwise operators (`&`, `|`, `~`, `^`).

- **Comparisons (`MIN`, `MAX`, `MINU`, `MAXU`)**:  
  - For the signed versions (`MIN` / `MAX`), the inputs were cast to a `signed` type to ensure correct two's complement comparison.  
  - For the unsigned versions, Verilog's default unsigned comparison was used.

- **Rotates (`ROL`, `ROR`)**:  
  Implemented using a combination of left and right shifts and a bitwise OR, as is standard.  
  A specific check (`shamt == 0`) was added to handle the rotate-by-zero case and prevent an invalid shift-by-32, as required by the assignment.

- **Absolute Value (`ABS`)**:  
  A signed comparison checks if the input is non-negative. If it is, the original value is passed through; otherwise, its two's complement negative is calculated and returned.
  
## How To Rum/Build

### 1. Requirements üíª

To build and run this project, you will need a SystemVerilog simulator. These instructions are tailored for **Xilinx Vivado**, but the process is similar for other simulators like ModelSim or Verilator.

* **Software:** Xilinx Vivado (or any SystemVerilog-compliant simulator)
* **Source Files:**
    * `riscvsingle.sv`: Contains the complete hardware description and testbench.
    * `riscvtest.mem`: The hexadecimal machine code for the test program.

---

### 2. Build and Run Instructions üöÄ

Follow these steps to compile the hardware and run the test program.

#### Step 1: Create a New Project

1.  Launch Vivado and create a new project by selecting **File > Project > New**.
2.  In the "Add Sources" dialog, click **Add Files**, navigate to your project directory, and select the `riscvsingle.sv` file. Ensure "Copy sources into project" is checked.
3.  Proceed through the wizard without adding constraints or selecting a part (this is not necessary for a behavioral simulation).



#### Step 2: Place the Test Program File

This is the most critical step. The simulator needs to find your test program to load it into the instruction memory.

1.  Navigate to your Vivado project directory on your computer.
2.  Find the simulation folder, which is typically located at `<Your_Project_Folder>/<Project_Name>.sim/sim_1/behav/xsim/`.
3.  **Copy** your test program file (`riscvtest.mem`) into this `xsim` directory.

The hardware's `$readmemh` task looks for the file in the directory where the simulation is run, which is why this placement is necessary.

#### Step 3: Run the Simulation

1.  In the Vivado "Flow Navigator" pane on the left, click **Run Simulation > Run Behavioral Simulation**.
2.  The simulator will compile your `riscvsingle.sv` file and launch the simulation GUI. The test program will start running automatically.

#### Step 4: Check the Results

The results will be printed in the **Tcl Console** at the bottom of the Vivado window.

* ‚úÖ **If the simulation is successful**, you will see the following message, and the simulation will stop:
    ```
    Simulation succeeded
    ```

* ‚ùå **If the simulation fails**, the test program will write the ID of the failing test case to memory address 96. You will see this message:
    ```
    Simulation failed at test case ID stored in mem[96]
    ```

---

### 3. Troubleshooting üõ†Ô∏è

* **`WARNING: Too many words specified in data file...`**: This means your `riscvtest.mem` program is larger than the memory defined in your `imem` module in `riscvsingle.sv`. To fix it, increase the size of the `RAM` array inside the `imem` module (e.g., from `RAM[63:0]` to `RAM[255:0]`).
* **File Not Found Error**: If the simulator reports that it cannot find `riscvtest.mem`, double-check that you have placed the file in the correct simulation directory as described in Step 2.
